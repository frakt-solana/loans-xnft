{"ast":null,"code":"import _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/asyncToGenerator\";\nexport var signAndSendAllTransactions = function () {\n  var _ref2 = _asyncToGenerator(function* (_ref) {\n    var txnAndSignersArray = _ref.txnAndSignersArray,\n      connection = _ref.connection,\n      wallet = _ref.wallet,\n      _ref$commitment = _ref.commitment,\n      commitment = _ref$commitment === void 0 ? 'finalized' : _ref$commitment,\n      onBeforeApprove = _ref.onBeforeApprove,\n      onAfterSend = _ref.onAfterSend;\n    onBeforeApprove == null ? void 0 : onBeforeApprove();\n    var _yield$connection$get = yield connection.getLatestBlockhash(),\n      blockhash = _yield$connection$get.blockhash,\n      lastValidBlockHeight = _yield$connection$get.lastValidBlockHeight;\n    var transactions = txnAndSignersArray.map(function (_ref3) {\n      var transaction = _ref3.transaction,\n        _ref3$signers = _ref3.signers,\n        signers = _ref3$signers === void 0 ? [] : _ref3$signers;\n      transaction.recentBlockhash = blockhash;\n      transaction.feePayer = wallet.publicKey;\n      if (signers.length) {\n        transaction.sign.apply(transaction, _toConsumableArray(signers));\n      }\n      return transaction;\n    });\n    var signedTransactions = yield wallet.signAllTransactions(transactions);\n    var txnSignatures = yield Promise.all(signedTransactions.map(function (txn) {\n      return connection.sendRawTransaction(txn.serialize(), {\n        skipPreflight: false\n      });\n    }));\n    onAfterSend == null ? void 0 : onAfterSend();\n    return yield Promise.allSettled(txnSignatures.map(function (signature) {\n      return connection.confirmTransaction({\n        signature: signature,\n        blockhash: blockhash,\n        lastValidBlockHeight: lastValidBlockHeight\n      }, commitment);\n    }));\n  });\n  return function signAndSendAllTransactions(_x) {\n    return _ref2.apply(this, arguments);\n  };\n}();","map":{"version":3,"names":["signAndSendAllTransactions","_ref2","_asyncToGenerator","_ref","txnAndSignersArray","connection","wallet","_ref$commitment","commitment","onBeforeApprove","onAfterSend","_yield$connection$get","getLatestBlockhash","blockhash","lastValidBlockHeight","transactions","map","_ref3","transaction","_ref3$signers","signers","recentBlockhash","feePayer","publicKey","length","sign","apply","_toConsumableArray","signedTransactions","signAllTransactions","txnSignatures","Promise","all","txn","sendRawTransaction","serialize","skipPreflight","allSettled","signature","confirmTransaction","_x","arguments"],"sources":["/Users/ezekiel/Desktop/frakt/loans-xnft/src/utils/signAndSendAllTransactions.ts"],"sourcesContent":["import { Wallet } from '@frakt-protocol/frakt-sdk/lib/common/classes/nodewallet'\nimport { web3 } from '@frakt-protocol/frakt-sdk'\n\ninterface TxnAndSigners {\n  transaction: web3.Transaction\n  signers?: web3.Signer[]\n}\n\nexport type SignAndSendAllTransactions = (props: {\n  txnAndSignersArray: TxnAndSigners[]\n  connection: web3.Connection\n  wallet: Wallet\n  commitment?: web3.Commitment\n  onBeforeApprove?: () => void\n  onAfterSend?: () => void\n}) => Promise<\n  PromiseSettledResult<web3.RpcResponseAndContext<web3.SignatureResult>>[]\n>\nexport const signAndSendAllTransactions: SignAndSendAllTransactions = async ({\n  txnAndSignersArray,\n  connection,\n  wallet,\n  commitment = 'finalized',\n  onBeforeApprove,\n  onAfterSend,\n}) => {\n  onBeforeApprove?.()\n\n  const { blockhash, lastValidBlockHeight } =\n    await connection.getLatestBlockhash()\n\n  const transactions = txnAndSignersArray.map(\n    ({ transaction, signers = [] }) => {\n      transaction.recentBlockhash = blockhash\n      transaction.feePayer = wallet.publicKey\n\n      if (signers.length) {\n        transaction.sign(...signers)\n      }\n\n      return transaction\n    }\n  )\n\n  const signedTransactions = await wallet.signAllTransactions(transactions)\n\n  const txnSignatures = await Promise.all(\n    signedTransactions.map((txn) =>\n      connection.sendRawTransaction(txn.serialize(), {\n        skipPreflight: false,\n      })\n    )\n  )\n\n  onAfterSend?.()\n\n  return await Promise.allSettled(\n    txnSignatures.map((signature) =>\n      connection.confirmTransaction(\n        {\n          signature,\n          blockhash,\n          lastValidBlockHeight,\n        },\n        commitment\n      )\n    )\n  )\n}\n"],"mappings":";;AAkBA,OAAO,IAAMA,0BAAsD;EAAA,IAAAC,KAAA,GAAAC,iBAAA,CAAG,WAAAC,IAAA,EAOhE;IAAA,IANJC,kBAAkB,GAAAD,IAAA,CAAlBC,kBAAkB;MAClBC,UAAU,GAAAF,IAAA,CAAVE,UAAU;MACVC,MAAM,GAAAH,IAAA,CAANG,MAAM;MAAAC,eAAA,GAAAJ,IAAA,CACNK,UAAU;MAAVA,UAAU,GAAAD,eAAA,cAAG,WAAW,GAAAA,eAAA;MACxBE,eAAe,GAAAN,IAAA,CAAfM,eAAe;MACfC,WAAW,GAAAP,IAAA,CAAXO,WAAW;IAEXD,eAAe,oBAAfA,eAAe,EAAI;IAEnB,IAAAE,qBAAA,SACQN,UAAU,CAACO,kBAAkB,EAAE;MAD/BC,SAAS,GAAAF,qBAAA,CAATE,SAAS;MAAEC,oBAAoB,GAAAH,qBAAA,CAApBG,oBAAoB;IAGvC,IAAMC,YAAY,GAAGX,kBAAkB,CAACY,GAAG,CACzC,UAAAC,KAAA,EAAmC;MAAA,IAAhCC,WAAW,GAAAD,KAAA,CAAXC,WAAW;QAAAC,aAAA,GAAAF,KAAA,CAAEG,OAAO;QAAPA,OAAO,GAAAD,aAAA,cAAG,EAAE,GAAAA,aAAA;MAC1BD,WAAW,CAACG,eAAe,GAAGR,SAAS;MACvCK,WAAW,CAACI,QAAQ,GAAGhB,MAAM,CAACiB,SAAS;MAEvC,IAAIH,OAAO,CAACI,MAAM,EAAE;QAClBN,WAAW,CAACO,IAAI,CAAAC,KAAA,CAAhBR,WAAW,EAAAS,kBAAA,CAASP,OAAO,EAAC;MAC9B;MAEA,OAAOF,WAAW;IACpB,CAAC,CACF;IAED,IAAMU,kBAAkB,SAAStB,MAAM,CAACuB,mBAAmB,CAACd,YAAY,CAAC;IAEzE,IAAMe,aAAa,SAASC,OAAO,CAACC,GAAG,CACrCJ,kBAAkB,CAACZ,GAAG,CAAC,UAACiB,GAAG;MAAA,OACzB5B,UAAU,CAAC6B,kBAAkB,CAACD,GAAG,CAACE,SAAS,EAAE,EAAE;QAC7CC,aAAa,EAAE;MACjB,CAAC,CAAC;IAAA,EACH,CACF;IAED1B,WAAW,oBAAXA,WAAW,EAAI;IAEf,aAAaqB,OAAO,CAACM,UAAU,CAC7BP,aAAa,CAACd,GAAG,CAAC,UAACsB,SAAS;MAAA,OAC1BjC,UAAU,CAACkC,kBAAkB,CAC3B;QACED,SAAS,EAATA,SAAS;QACTzB,SAAS,EAATA,SAAS;QACTC,oBAAoB,EAApBA;MACF,CAAC,EACDN,UAAU,CACX;IAAA,EACF,CACF;EACH,CAAC;EAAA,gBAlDYR,0BAAsDA,CAAAwC,EAAA;IAAA,OAAAvC,KAAA,CAAAyB,KAAA,OAAAe,SAAA;EAAA;AAAA,GAkDlE"},"metadata":{},"sourceType":"module","externalDependencies":[]}